{"version":3,"file":"updateAppState.js","sources":["../../../../../src/v2/client/updateAppState.ts"],"sourcesContent":["import { IdxResponse } from \"@okta/okta-auth-js\";\nimport AppState from '../models/AppState';\nimport sessionStorageHelper from './sessionStorageHelper';\nimport { interactionCodeFlow } from './interactionCodeFlow';\nimport { FORMS } from \"../ion/RemediationConstants\";\nimport transformIdxResponse from '../ion/transformIdxResponse';\n\n\nexport async function updateAppState(appState: AppState, idxResponse: IdxResponse): Promise<void> {\n  const settings = appState.settings;\n\n  const lastResponse = appState.get('idx');\n  const useInteractionCodeFlow = settings.get('oauth2Enabled');\n  if (useInteractionCodeFlow) {\n    if (idxResponse.interactionCode) {\n      // Although session.stateHandle isn't used by interation flow,\n      // it's better to clean up at the end of the flow.\n      sessionStorageHelper.removeStateHandle();\n      // This is the end of the IDX flow, now entering OAuth\n      const tokens = await interactionCodeFlow(settings, idxResponse);\n      // At the successful end of IDX flow `clearAppStateCache` has been called, \n      //  but `setIonResponse` is not called, so `appState` is empty.\n      // In such case `FormController` is not able to render any form.\n      appState.unset('currentFormName', { silent: true });\n      return tokens;\n    }  \n  } else {\n    // Do not save state handle for the first page loads.\n    // Because there shall be no difference between following behavior\n    // 1. bootstrap widget\n    //    -> save state handle to session storage\n    //    -> refresh page\n    //    -> introspect using sessionStorage.stateHandle\n    // 2. bootstrap widget\n    //    -> do not save state handle to session storage\n    //    -> refresh page\n    //    -> introspect using options.stateHandle\n    if (lastResponse) {\n      sessionStorageHelper.setStateHandle(idxResponse?.context?.stateHandle);\n    }\n    // Login flows that mimic step up (moving forward in login pipeline) via internal api calls,\n    // need to clear stored stateHandles.\n    // This way the flow can maintain the latest state handle. For eg. Device probe calls\n    if (appState.get('currentFormName') === FORMS.CANCEL_TRANSACTION) {\n      sessionStorageHelper.removeStateHandle();\n    }\n  }\n\n  // transform response\n  const ionResponse = transformIdxResponse(settings, idxResponse, lastResponse);\n\n  await appState.setIonResponse(ionResponse);\n}\n"],"names":["updateAppState","appState","idxResponse","settings","lastResponse","get","useInteractionCodeFlow","interactionCode","sessionStorageHelper","removeStateHandle","tokens","interactionCodeFlow","unset","silent","setStateHandle","context","stateHandle","FORMS","CANCEL_TRANSACTION","ionResponse","transformIdxResponse","setIonResponse"],"mappings":";;;;;AAQO,eAAeA,cAAc,CAACC,QAAkB,EAAEC,WAAwB,EAAiB;AAChG,EAAA,MAAMC,QAAQ,GAAGF,QAAQ,CAACE,QAAQ,CAAA;AAElC,EAAA,MAAMC,YAAY,GAAGH,QAAQ,CAACI,GAAG,CAAC,KAAK,CAAC,CAAA;AACxC,EAAA,MAAMC,sBAAsB,GAAGH,QAAQ,CAACE,GAAG,CAAC,eAAe,CAAC,CAAA;AAC5D,EAAA,IAAIC,sBAAsB,EAAE;IAC1B,IAAIJ,WAAW,CAACK,eAAe,EAAE;AAC/B;AACA;MACAC,oBAAoB,CAACC,iBAAiB,EAAE,CAAA;AACxC;MACA,MAAMC,MAAM,GAAG,MAAMC,mBAAmB,CAACR,QAAQ,EAAED,WAAW,CAAC,CAAA;AAC/D;AACA;AACA;AACAD,MAAAA,QAAQ,CAACW,KAAK,CAAC,iBAAiB,EAAE;AAAEC,QAAAA,MAAM,EAAE,IAAA;AAAK,OAAC,CAAC,CAAA;AACnD,MAAA,OAAOH,MAAM,CAAA;AACf,KAAA;AACF,GAAC,MAAM;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAA,IAAIN,YAAY,EAAE;AAAA,MAAA,IAAA,oBAAA,CAAA;AAChBI,MAAAA,oBAAoB,CAACM,cAAc,CAACZ,WAAW,KAAXA,IAAAA,IAAAA,WAAW,KAAXA,KAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,CAAAA,oBAAAA,GAAAA,WAAW,CAAEa,OAAO,MAApB,IAAA,IAAA,oBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,oBAAA,CAAsBC,WAAW,CAAC,CAAA;AACxE,KAAA;AACA;AACA;AACA;IACA,IAAIf,QAAQ,CAACI,GAAG,CAAC,iBAAiB,CAAC,KAAKY,KAAK,CAACC,kBAAkB,EAAE;MAChEV,oBAAoB,CAACC,iBAAiB,EAAE,CAAA;AAC1C,KAAA;AACF,GAAA;;AAEA;EACA,MAAMU,WAAW,GAAGC,oBAAoB,CAACjB,QAAQ,EAAED,WAAW,EAAEE,YAAY,CAAC,CAAA;AAE7E,EAAA,MAAMH,QAAQ,CAACoB,cAAc,CAACF,WAAW,CAAC,CAAA;AAC5C;;;;"}